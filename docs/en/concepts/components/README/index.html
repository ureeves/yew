<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>concepts/components/README · Yew Docs</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Components and their lifecycle hooks"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="concepts/components/README · Yew Docs"/><meta property="og:type" content="website"/><meta property="og:url" content="https://yew.rs/"/><meta property="og:description" content="Components and their lifecycle hooks"/><meta property="og:image" content="https://yew.rs/img/Rollup.jpg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://yew.rs/img/Rollup.jpg"/><link rel="shortcut icon" href="/img/logo.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,400i,500,700"/><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/en"><img class="logo" src="/img/logo.png" alt="Yew Docs"/><h2 class="headerTitleWithLogo">Yew Docs</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="https://github.com/yewstack/yew/releases" target="_self">Changelog</a></li><li class=""><a href="https://docs.rs/yew" target="_self">API</a></li><li class=""><a href="https://discord.gg/VQck8X4" target="_self">Discord</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>English</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/zh-CN/concepts/components/README">中文</a></li><li><a href="/docs/zh-TW/concepts/components/README">繁體中文</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">concepts/components/README</h1></header><article><div><span><h1><a class="anchor" aria-hidden="true" id="components"></a><a href="#components" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Components</h1>
<h2><a class="anchor" aria-hidden="true" id="what-are-components"></a><a href="#what-are-components" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What are Components?</h2>
<p>Components are the building blocks of Yew. They manage their own state and can render themselves to the DOM. Components are created by implementing the <code>Component</code> trait which describes the lifecycle of a component.</p>
<h2><a class="anchor" aria-hidden="true" id="lifecycle"></a><a href="#lifecycle" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lifecycle</h2>
<p>{% hint style=&quot;info&quot; %}
<code>Contribute to our docs:</code> <a href="https://github.com/yewstack/docs/issues/22">Add a diagram of the component lifecycle</a>
{% endhint %}</p>
<h2><a class="anchor" aria-hidden="true" id="lifecycle-methods"></a><a href="#lifecycle-methods" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lifecycle Methods</h2>
<h3><a class="anchor" aria-hidden="true" id="create"></a><a href="#create" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Create</h3>
<p>When a component is created, it receives properties from its parent component as well as a <code>ComponentLink</code>. The properties can be used to initialize the component's state and the &quot;link&quot; can be used to register callbacks or send messages to the component.</p>
<p>It is common to store the props and the link in your component struct, like so:</p>
<pre><code class="hljs css language-rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyComponent</span></span> {
    props: Props,
    link: ComponentLink&lt;<span class="hljs-keyword">Self</span>&gt;,
}

<span class="hljs-keyword">impl</span> Component <span class="hljs-keyword">for</span> MyComponent {
    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Properties</span></span> = Props;
    <span class="hljs-comment">// ...</span>

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">create</span></span>(props: Self::Properties, link: ComponentLink&lt;<span class="hljs-keyword">Self</span>&gt;) -&gt; <span class="hljs-keyword">Self</span> {
        MyComponent { props, link }
    }

    <span class="hljs-comment">// ...</span>
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="view"></a><a href="#view" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>View</h3>
<p>Components declare their layout in the <code>view()</code> method. Yew provides the <code>html!</code> macro for declaring HTML and SVG nodes and their listeners as well as child components. The macro acts a lot like React's JSX, but uses Rust expressions instead of JavaScript.</p>
<pre><code class="hljs css language-rust">impl Component for MyComponent {
    // ...

    fn view(&amp;self) -&gt; Html {
        let onclick = self.link.callback(|_| Msg::Click);
        html! {
            &lt;button onclick=onclick&gt;{ self.props.button_text }&lt;/button&gt;
        }
    }
}
</code></pre>
<p>For usage details, check out the <code>html!</code> guide:</p>
<p>{% page-ref page=&quot;../html/&quot; %}</p>
<h3><a class="anchor" aria-hidden="true" id="rendered"></a><a href="#rendered" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Rendered</h3>
<p>The <code>rendered()</code> component lifecycle method is called after <code>view()</code> is processed and Yew has rendered your component, but before the browser refreshes the page. A component may wish to implement this method to perform actions that can only be done after the component has rendered elements. You can check whether this is the first time the component was rendered via the <code>first_render</code> parameter.</p>
<pre><code class="hljs css language-rust">use stdweb::web::html_element::InputElement;
use stdweb::web::IHtmlElement;
use yew::prelude::*;

pub struct MyComponent {
    node_ref: NodeRef,
}

impl Component for MyComponent {
    // ...

    fn view(&amp;self) -&gt; Html {
        html! {
            &lt;input ref=self.node_ref.clone() type="text" /&gt;
        }
    }

    fn rendered(&amp;mut self, first_render: bool) {
        if first_render {
            if let Some(input) = self.node_ref.try_into::&lt;InputElement&gt;() {
                input.focus();
            }
        }
    }
}
</code></pre>
<p>{% hint style=&quot;info&quot; %}
Note that this lifecycle method does not require an implementation and will do nothing by default
{% endhint %}</p>
<h3><a class="anchor" aria-hidden="true" id="update"></a><a href="#update" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Update</h3>
<p>Components are dynamic and can register to receive asynchronous messages. The <code>update()</code> lifecycle method is called for each message. This allows the component to update itself based on what the message was, and determine if it needs to re-render itself. Messages can be triggered by HTML elements listeners or be sent by child components, Agents, Services, or Futures.</p>
<p>Here's an example of what <code>update()</code> could look like:</p>
<pre><code class="hljs css language-rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Msg</span></span> {
    SetInputEnabled(<span class="hljs-built_in">bool</span>)
}

<span class="hljs-keyword">impl</span> Component <span class="hljs-keyword">for</span> MyComponent {
    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Message</span></span> = Msg;

    <span class="hljs-comment">// ...</span>

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">update</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, msg: Self::Message) -&gt; ShouldRender {
       <span class="hljs-keyword">match</span> msg {
           Msg::SetInputEnabled(enabled) =&gt; {
               <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.input_enabled != enabled {
                   <span class="hljs-keyword">self</span>.input_enabled = enabled;
                   <span class="hljs-literal">true</span> <span class="hljs-comment">// Re-render</span>
               } <span class="hljs-keyword">else</span> {
                   <span class="hljs-literal">false</span>
               }
           }
       }
    }
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="change"></a><a href="#change" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Change</h3>
<p>Components may be re-rendered by their parents. When this happens, they could receive new properties and choose to re-render. This design facilitates parent to child component communication through changed properties.</p>
<p>A typical implementation would look like:</p>
<pre><code class="hljs css language-rust"><span class="hljs-keyword">impl</span> Component <span class="hljs-keyword">for</span> MyComponent {
    <span class="hljs-comment">// ...</span>

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">change</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, props: Self::Properties) -&gt; ShouldRender {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.props != props {
            <span class="hljs-keyword">self</span>.props = props;
            <span class="hljs-literal">true</span>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-literal">false</span>
        }
    }
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="destroy"></a><a href="#destroy" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Destroy</h3>
<p>After Components are unmounted from the DOM, Yew calls the <code>destroy()</code> lifecycle method to support any necessary clean up operations. This method is optional and does nothing by default.</p>
<h2><a class="anchor" aria-hidden="true" id="associated-types"></a><a href="#associated-types" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Associated Types</h2>
<p>The <code>Component</code> trait has two associated types: <code>Message</code> and <code>Properties</code>.</p>
<pre><code class="hljs css language-rust"><span class="hljs-keyword">impl</span> Component <span class="hljs-keyword">for</span> MyComponent {
    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Message</span></span> = Msg;
    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Properties</span></span> = Props;

    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p><code>Message</code> represents a variety of messages that can be processed by the component to trigger some side effect. For example, you may have a <code>Click</code> message which triggers an API request or toggles the appearance of a UI component. It is common practice to create an enum called <code>Msg</code> in your component's module and use that as the message type in the component. It is common to shorten &quot;message&quot; to &quot;msg&quot;.</p>
<pre><code class="hljs css language-rust"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Msg</span></span> {
    Click,
}
</code></pre>
<p><code>Properties</code> represents the information passed to a component from its parent. This type must implements the <code>Properties</code> trait (usually by deriving it) and can specify whether certain properties are required or optional. This type is used when creating and updating a component. It is common practice to create a struct called <code>Props</code> in your component's module and use that as the component's <code>Properties</code> type. It is common to shorten &quot;properties&quot; to &quot;props&quot;. Since props are handed down from parent components, the root component of your application typically has a <code>Properties</code> type of <code>()</code>. If you wish to specify properties for your root component, use the <code>App::mount_with_props</code> method.</p>
</span></div></article></div><div class="docLastUpdate"><em>Last updated on 7/10/2020</em></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#what-are-components">What are Components?</a></li><li><a href="#lifecycle">Lifecycle</a></li><li><a href="#lifecycle-methods">Lifecycle Methods</a><ul class="toc-headings"><li><a href="#create">Create</a></li><li><a href="#view">View</a></li><li><a href="#rendered">Rendered</a></li><li><a href="#update">Update</a></li><li><a href="#change">Change</a></li><li><a href="#destroy">Destroy</a></li></ul></li><li><a href="#associated-types">Associated Types</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"></a><div><h5>Support</h5><a href="https://issuehunt.io/r/yewstack/yew" target="_blank" rel="noreferrer noopener">Fund Issues</a><a href="https://opencollective.com/yew" target="_blank" rel="noreferrer noopener">Sponsor Project</a></div><div><h5>Participate</h5><a href="https://github.com/yewstack/yew" target="_blank" rel="noreferrer noopener">Github</a><a href="https://discord.gg/VQck8X4" target="_blank" rel="noreferrer noopener">Discord</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="https://github.com/jetli/awesome-yew" target="_blank" rel="noreferrer noopener">Yew Awesome</a></div></section></footer></div><script>window.twttr=(function(d,s, id){var js,fjs=d.getElementsByTagName(s)[0],t=window.twttr||{};if(d.getElementById(id))return t;js=d.createElement(s);js.id=id;js.src='https://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js, fjs);t._e = [];t.ready = function(f) {t._e.push(f);};return t;}(document, 'script', 'twitter-wjs'));</script></body></html>